import './show-whitespace.css';
import React from 'dom-chef';
import select from 'select-dom';
import delegate from 'delegate-it';
import * as pageDetect from 'github-url-detection';

import features from '.';
import getTextNodes from '../helpers/get-text-nodes';
import onNewComments from '../github-events/on-new-comments';
import {onDiffFileLoad} from '../github-events/on-fragment-load';
import {codeElementsSelector} from '../github-helpers/dom-formatters';

// `splitText` is used before and after each whitespace group so a new whitespace-only text node is created. This new node is then wrapped in a <span>
function showWhiteSpacesOn(line: Element): void {
	const shouldAvoidSurroundingSpaces = Boolean(line.closest('.blob-wrapper-embedded')); // #2285
	const textNodesOnThisLine = getTextNodes(line);
	for (const [nodeIndex, textNode] of textNodesOnThisLine.entries()) {
		// `textContent` reads must be cached #2737
		let text = textNode.textContent!;
		if (text.length > 1000) { // #5092
			continue;
		}

		// This referes to the boundary text nodes, not actual whitespace nodes. Text nodes are generated by the syntax highlighter, so non-highlighted text will have one text node.
		const isLeading = nodeIndex === 0;
		const isTrailing = nodeIndex === textNodesOnThisLine.length - 1;

		const startingCharacter = shouldAvoidSurroundingSpaces && isLeading ? 1 : 0;
		const skipLastCharacter = shouldAvoidSurroundingSpaces && isTrailing;
		const endingCharacter = text.length - 1 - Number(skipLastCharacter);

		// Loop goes in reverse otherwise `splitText`'s `index` parameter needs to keep track of the previous split
		for (let i = endingCharacter; i >= startingCharacter; i--) {
			const thisCharacter = text[i];
			const endingIndex = i;

			// Exclude irrelevant characters
			if (thisCharacter !== ' ' && thisCharacter !== '\t') {
				continue;
			}

			// Find the same character so they can be wrapped together, but stop at `startingCharacter`
			let isConsecutive = false;
			while (text[i - 1] === thisCharacter && !(i === startingCharacter)) {
				i--;
				isConsecutive = true;
			}

			// Skip non-boundary single spaces
			if (!isLeading && !isTrailing && !isConsecutive && thisCharacter === ' ') {
				continue;
			}

			if (endingIndex < text.length - 1) {
				textNode.splitText(endingIndex + 1);
			}

			textNode.splitText(i);

			// Update cached variable here because it just changed
			text = textNode.textContent!;

			textNode.after(
				<span data-rgh-whitespace={thisCharacter === '\t' ? 'tab' : 'space'}>
					{textNode.nextSibling}
				</span>,
			);
		}
	}
}

const viewportObserver = new IntersectionObserver(changes => {
	for (const change of changes) {
		if (change.isIntersecting) {
			showWhiteSpacesOn(change.target);
			viewportObserver.unobserve(change.target);
		}
	}
});

function observeWhiteSpace(): void {
	for (const line of select.all(`:is(${codeElementsSelector}):not(.rgh-observing-whitespace, .blob-code-hunk)`)) {
		line.classList.add('rgh-observing-whitespace');
		viewportObserver.observe(line);
	}
}

function init(): Deinit {
	observeWhiteSpace();

	return [
		viewportObserver,
		// Show whitespace on new review suggestions #2852
		// This event is not very reliable as it also triggers when review comments are edited or deleted
		delegate(document, '.js-pull-refresh-on-pjax', 'socket:message', observeWhiteSpace, {capture: true}),
	];
}

void features.add(import.meta.url, {
	include: [
		pageDetect.hasCode,
	],
	additionalListeners: [
		onNewComments,
		onDiffFileLoad,
	],
	deduplicate: '.rgh-observing-whitespace',
	init,
});

/*
TEST URL
https://github.com/refined-github/sandbox/pull/18
*/
